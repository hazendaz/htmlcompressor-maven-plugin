<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileTool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">htmlcompressor-maven-plugin</a> &gt; <a href="index.source.html" class="el_package">com.tunyk.mvn.plugins.htmlcompressor</a> &gt; <span class="el_source">FileTool.java</span></div><h1>FileTool.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2011-2025 Alex Tunyk &lt;alex at tunyk.com&gt;.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 */
package com.tunyk.mvn.plugins.htmlcompressor;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Matcher;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.json.JSONException;
import org.json.JSONObject;

/**
 * The Class FileTool.
 */
public class FileTool {

    /** The root dir path. */
    private String rootDirPath;

    /** The file extensions. */
    private String[] fileExtensions;

    /** The recursive. */
    private boolean recursive;

    /** The file encoding. */
    private Charset fileEncoding;

    /**
     * Instantiates a new file tool.
     *
     * @param rootDir
     *            the root dir
     * @param fileExtensions
     *            the file ext
     * @param recursive
     *            the recursive
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
<span class="fc" id="L68">    public FileTool(String rootDir, String[] fileExtensions, boolean recursive) throws IOException {</span>
<span class="fc" id="L69">        this.setRootDirPath(rootDir);</span>
<span class="fc" id="L70">        this.fileExtensions = fileExtensions;</span>
<span class="fc" id="L71">        this.recursive = recursive;</span>
<span class="fc" id="L72">    }</span>

    /**
     * Gets the files.
     *
     * @return the files
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public ConcurrentMap&lt;String, String&gt; getFiles() throws IOException {
<span class="fc" id="L83">        ConcurrentMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L84">        Path rootDir = Path.of(rootDirPath);</span>
        List&lt;Path&gt; paths;
<span class="fc" id="L86">        try (Stream&lt;Path&gt; walk = Files.walk(rootDir)) {</span>
<span class="fc" id="L87">            paths = walk.map(Path::normalize).filter(Files::isRegularFile)</span>
<span class="fc" id="L88">                    .filter(path -&gt; Arrays.stream(fileExtensions).anyMatch(path.getFileName().toString()::endsWith))</span>
<span class="fc" id="L89">                    .collect(Collectors.toList());</span>
        }
<span class="fc" id="L91">        int truncationIndex = 0;</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (Path path : paths) {</span>
<span class="fc" id="L93">            String normalizedFilePath = path.toFile().getCanonicalPath().replace(&quot;\\&quot;, &quot;/&quot;);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (truncationIndex == 0) {</span>
<span class="fc" id="L95">                truncationIndex = normalizedFilePath.indexOf(rootDirPath) + rootDirPath.length() + 1;</span>
            }
<span class="fc" id="L97">            String key = normalizedFilePath.substring(truncationIndex);</span>
<span class="fc" id="L98">            String value = Files.readString(path, getFileEncoding());</span>
<span class="fc" id="L99">            map.put(key, value);</span>
<span class="fc" id="L100">        }</span>
<span class="fc" id="L101">        return map;</span>
    }

    /**
     * Write files.
     *
     * @param map
     *            the map
     * @param targetDir
     *            the target dir
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public void writeFiles(Map&lt;String, String&gt; map, String targetDir) throws IOException {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (Entry&lt;String, String&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L117">            Path path = Path.of(targetDir + '/' + entry.getKey());</span>
<span class="fc" id="L118">            Files.createDirectories(path.getParent());</span>
<span class="fc" id="L119">            Files.writeString(path, entry.getValue(), getFileEncoding());</span>
<span class="fc" id="L120">        }</span>
<span class="fc" id="L121">    }</span>

    /**
     * Write to json file.
     *
     * @param map
     *            the map
     * @param targetFile
     *            the target file
     * @param integrationCode
     *            the integration code
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     * @throws JSONException
     *             the JSON exception
     */
    public void writeToJsonFile(Map&lt;String, String&gt; map, String targetFile, String integrationCode)
            throws IOException, JSONException {
<span class="fc" id="L140">        String replacePattern = &quot;%s&quot;;</span>
<span class="fc" id="L141">        Path path = Path.of(targetFile);</span>
<span class="fc" id="L142">        JSONObject json = new JSONObject();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (Entry&lt;String, String&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L144">            json.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L145">        }</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (integrationCode == null) {</span>
<span class="nc" id="L147">            integrationCode = replacePattern;</span>
        }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (integrationCode.indexOf(replacePattern) == -1) {</span>
<span class="nc" id="L150">            integrationCode += replacePattern;</span>
        }
<span class="fc" id="L152">        String contents = integrationCode.replaceFirst(replacePattern, Matcher.quoteReplacement(json.toString()));</span>
<span class="fc" id="L153">        Files.createDirectories(path.getParent());</span>
<span class="fc" id="L154">        Files.writeString(path, contents, getFileEncoding());</span>
<span class="fc" id="L155">    }</span>

    /**
     * Human readable byte count.
     *
     * @param bytes
     *            the bytes
     * @param systemOfUnits
     *            the systemOfUnits
     *
     * @return the string
     */
    // TODO JWL 4/22/2023 Didn't see a good way to handle as it gets flagged to remove unnecessary cast if I fix this
    // per error-prone, so ignoring it
    @SuppressWarnings(&quot;LongDoubleConversion&quot;)
    public static String humanReadableByteCount(long bytes, boolean systemOfUnits) {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        int unit = systemOfUnits ? 1000 : 1024;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (bytes &lt; unit) {</span>
<span class="fc" id="L173">            return bytes + &quot; B&quot;;</span>
        }
<span class="nc" id="L175">        int exp = (int) (Math.log(bytes) / Math.log(unit));</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">        String pre = (systemOfUnits ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp - 1) + (systemOfUnits ? &quot;&quot; : &quot;i&quot;);</span>
<span class="nc" id="L177">        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);</span>
    }

    /**
     * Gets the elapsed HMS time.
     *
     * @param elapsedTime
     *            the elapsed time
     *
     * @return the elapsed HMS time
     */
    public static String getElapsedHMSTime(long elapsedTime) {
<span class="fc" id="L189">        String format = String.format(&quot;%%0%dd&quot;, 2);</span>
<span class="fc" id="L190">        elapsedTime = elapsedTime / 1000;</span>
<span class="fc" id="L191">        String seconds = String.format(format, elapsedTime % 60);</span>
<span class="fc" id="L192">        String minutes = String.format(format, (elapsedTime % 3600) / 60);</span>
<span class="fc" id="L193">        String hours = String.format(format, elapsedTime / 3600);</span>
<span class="fc" id="L194">        return hours + &quot;:&quot; + minutes + &quot;:&quot; + seconds;</span>
    }

    /**
     * Gets the root dir path.
     *
     * @return the root dir path
     */
    public String getRootDirPath() {
<span class="nc" id="L203">        return rootDirPath;</span>
    }

    /**
     * Sets the root dir path.
     *
     * @param rootDirPath
     *            the new root dir path
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public void setRootDirPath(String rootDirPath) throws IOException {
<span class="fc" id="L216">        Path path = Path.of(rootDirPath);</span>
<span class="fc" id="L217">        this.rootDirPath = path.toFile().getCanonicalPath().replace(&quot;\\&quot;, &quot;/&quot;).replaceAll(&quot;/$&quot;, &quot;&quot;);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Gets the file extensions.
     *
     * @return the file extensions
     */
    public String[] getFileExtensions() {
<span class="nc" id="L226">        return fileExtensions;</span>
    }

    /**
     * Sets the file extensions.
     *
     * @param fileExtensions
     *            the new file extensions
     */
    public void setFileExtensions(String[] fileExtensions) {
<span class="nc" id="L236">        this.fileExtensions = fileExtensions;</span>
<span class="nc" id="L237">    }</span>

    /**
     * Checks if is recursive.
     *
     * @return true, if is recursive
     */
    public boolean isRecursive() {
<span class="nc" id="L245">        return recursive;</span>
    }

    /**
     * Sets the recursive.
     *
     * @param recursive
     *            the new recursive
     */
    public void setRecursive(boolean recursive) {
<span class="nc" id="L255">        this.recursive = recursive;</span>
<span class="nc" id="L256">    }</span>

    /**
     * Gets the file encoding.
     *
     * @return the file encoding
     */
    public Charset getFileEncoding() {
<span class="fc bfc" id="L264" title="All 2 branches covered.">        return fileEncoding == null ? Charset.defaultCharset() : fileEncoding;</span>
    }

    /**
     * Sets the file encoding.
     *
     * @param fileEncoding
     *            the new file encoding
     */
    public void setFileEncoding(Charset fileEncoding) {
<span class="fc bfc" id="L274" title="All 2 branches covered.">        this.fileEncoding = fileEncoding == null ? Charset.defaultCharset() : fileEncoding;</span>
<span class="fc" id="L275">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>